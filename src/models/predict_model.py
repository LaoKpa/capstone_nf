import pandas as pd
import numpy as np
import time
from sklearn.metrics import accuracy_score, recall_score, f1_score, precision_score
from atomm.Tools import calc_open_position
from IPython.display import display, clear_output
#import src.models.train_model import run_combinations
def avg_model(  
    symbol_list,
    forecast_horizon,                                 
    input_window_size,
    ti_list,
    X_train,    
    X_test,    
    y_train,    
    y_test,    
    prices_test,
    model,
    silent = False,
    hyper_optimize=False,
    n_eval=10,
):
    """
    Averages predictions for different stocks.
    :param
    :param
    :param
    :returns
    """
    scores_dict, preds_dict, params_dict, returns_dict = {}, {}, {}, {}
    cnt = 1
    start = time.time()
    for symb in symbol_list:
        scores, preds, params, returns = run_combinations(
            symb,                             
            forecast_horizon,                                 
            input_window_size,
            ti_list,
            X_train,    
            X_test,    
            y_train,    
            y_test,    
            prices_test,   
            model=model,
            silent=True,
            hyper_optimize=hyper_optimize,
            n_eval=n_eval,
        )
        scores_dict[symb] = scores
        preds_dict[symb] = preds
        params_dict[symb] = params
        returns_dict[symb] = returns
        avg_results = pd.DataFrame(
            np.array([scores_dict[x].values for x in scores_dict.keys()]).mean(axis=0),
            columns=scores.columns, index=scores.index).style.background_gradient(cmap='BuGn')
        
        if silent == False:
            clear_output(wait=True)
            display(f'Leg [{cnt}/{len(symbol_list)}]; Elapsed Time {round(time.time()-start , 0)}s\n', avg_results)
        cnt += 1

    return avg_results, scores_dict, preds_dict, params_dict, returns_dict

import time
import pandas as pd
import atomm.Models.Tuning as mt

def run_combinations(
        symbol,
        forecast_horizon,
        input_window_size,
        ti_list,
        X_train,
        X_test,
        y_train,
        y_test,
        prices,
        model,
        hyper_optimize=False,
        n_eval=10,
        silent = False,
    
    ):
    start = time.time()
    cnt = 1
    df_score = pd.DataFrame(index=forecast_horizon, columns=input_window_size, dtype=float)
    df_score.rename_axis('Forecast horizon (days)').rename_axis('Input window (days)', axis=1)
    df_returns = df_score.copy()
    df_preds = df_score.copy()
    df_params = df_score.copy()
    total = len(forecast_horizon)*len(input_window_size)
    # Loop over forecast horizons
    try:
        for i, fh in enumerate(forecast_horizon):
            # Loop over input / lookback windows
            for j, iw in enumerate(input_window_size):

                params = {}
                if hyper_optimize:
                    _, _, params = BayesianSearch(
                        search_space(model),
                        model,
                        X_train[symbol][[f'{x}_{iw}' for x in ti_list]], 
                        y_train[symbol][f'signal_{fh}'], 
                        X_test[symbol][[f'{x}_{iw}' for x in ti_list]],
                        y_test[symbol][f'signal_{fh}'],
                        num_eval=n_eval,
                        silent=True,
                    )
                clf = model
                clf.fit(X_train[symbol][[f'{x}_{iw}' for x in ti_list]], y_train[symbol][f'signal_{fh}'])
                y_pred = clf.predict(X_test[symbol][[f'{x}_{iw}' for x in ti_list]])
                # Calculate accuracy score
                a_score = accuracy_score(y_test[symbol][f'signal_{fh}'], y_pred)
                # Calculate returns generated by strategy
                returns = calc_returns(y_pred, prices[symbol])
                cum_returns = returns['Cum_Returns_Strat'][-1]
                df_score.iloc[i, j] = a_score
                df_preds.iloc[i, j] = str(y_pred)
                df_params.iloc[i, j] = str(params)
                df_returns.iloc[i, j] = cum_returns
                if silent == False:
                    clear_output(wait=True)
                    display(f'Leg [{cnt} / {total}]; Test Score {a_score}; Test Returns {cum_returns}')
                cnt += 1
    except (KeyboardInterrupt, SystemExit):
        sys.exit(0)
    print(f'Elapsed time {round(time.time()-start, 0)}s.')
    return df_score, df_preds, df_params, df_returns

def calc_returns(signals, prices):
    returns = prices[['Close']].pct_change()
    returns['Signal_Strat'] = calc_open_position(signals)
    returns['Cum_Returns_Strat'] = (returns['Signal_Strat'] * returns['Close']).cumsum()
    returns['Cum_Returns_BH'] = returns['Close'].cumsum()
    return returns